/**
 * Wallet Handler
 * Handles all wallet-related operations including creation, management, and personal cabinet
 */

const { Markup } = require('telegraf');
const walletService = require('../services/walletService');
const priceService = require('../services/priceService');
const { isDatabaseConnected } = require('../database/models');
const sessionManager = require('./SessionManager');

class WalletHandler {
  // Handle Personal Cabinet from text message
  async handlePersonalCabinetText(ctx) {
    try {
      const chatId = ctx.chat.id.toString();
      console.log(`üè† Processing Personal Cabinet request for user ${chatId}`);
      
      let walletInfo = null;
      if (isDatabaseConnected()) {
        try {
          walletInfo = await walletService.getUserWallet(chatId);
        } catch (dbError) {
          console.error('Database error during wallet retrieval:', dbError);
        }
      }
      
      // If database is not available or user not found, create a mock wallet info
      if (!walletInfo) {
        walletInfo = {
          hasWallet: false
        };
      }
      
      if (!walletInfo) {
        console.log(`‚ùå User ${chatId} not found`);
        return await ctx.reply('‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω. –í—ã–ø–æ–ª–Ω–∏—Ç–µ /start');
      }
      
      // Header as requested
      let message = 'üë§ –õ–ò–ß–ù–´–ô –ö–ê–ë–ò–ù–ï–¢\n' +
                   '‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ\n';
      
      if (walletInfo.hasWallet) {
        console.log(`üíº User ${chatId} has wallet, showing wallet info`);
        // Get current price data for both tokens
        const [cesData, polData] = await Promise.all([
          priceService.getCESPrice(),
          priceService.getPOLPrice()
        ]);
      
        const cesTokenPrice = cesData ? cesData.price : 0;
        const cesTokenPriceRub = cesData ? cesData.priceRub : 0;
        const polTokenPrice = polData ? polData.price : 0.45;
        const polTokenPriceRub = polData ? polData.priceRub : 45.0;
      
        // Calculate total value of tokens on wallet
        const cesTotalUsd = (walletInfo.cesBalance * cesTokenPrice).toFixed(2);
        const cesTotalRub = (walletInfo.cesBalance * cesTokenPriceRub).toFixed(2);
        const polTotalUsd = (walletInfo.polBalance * polTokenPrice).toFixed(2);
        const polTotalRub = (walletInfo.polBalance * polTokenPriceRub).toFixed(2);
      
        // Format as requested with escrow information
        let cesBalanceText = `–ë–∞–ª–∞–Ω—Å CES: ${walletInfo.cesBalance.toFixed(4)}`;
        if (walletInfo.escrowCESBalance > 0) {
          cesBalanceText += ` (–≤ —ç—Å–∫—Ä–æ—É: ${walletInfo.escrowCESBalance.toFixed(4)})`;
        }
        cesBalanceText += ` ‚Ä¢ $ ${cesTotalUsd} ‚Ä¢ ‚ÇΩ ${cesTotalRub}\n`;
        
        let polBalanceText = `–ë–∞–ª–∞–Ω—Å POL: ${walletInfo.polBalance.toFixed(4)}`;
        if (walletInfo.escrowPOLBalance > 0) {
          polBalanceText += ` (–≤ —ç—Å–∫—Ä–æ—É: ${walletInfo.escrowPOLBalance.toFixed(4)})`;
        }
        polBalanceText += ` ‚Ä¢ $ ${polTotalUsd} ‚Ä¢ ‚ÇΩ ${polTotalRub}\n`;
        
        message += cesBalanceText + polBalanceText;
      
        // Removed the refresh button as requested
        const keyboard = Markup.inlineKeyboard([
          [Markup.button.callback('üí≥ –ö–æ—à–µ–ª–µ–∫', 'wallet_details')],
          [Markup.button.callback('üí∏ –ü–µ—Ä–µ–≤–æ–¥', 'transfer_menu')]
        ]);
      
        await ctx.reply(message, { parse_mode: 'Markdown', ...keyboard });
      
      } else {
        console.log(`‚ö†Ô∏è User ${chatId} has no wallet, showing wallet creation prompt`);
        message += '‚ö†Ô∏è –ö–æ—à–µ–ª–µ–∫ –Ω–µ —Å–æ–∑–¥–∞–Ω\n\n';
        message += 'üí° –°–æ–∑–¥–∞–π—Ç–µ –∫–æ—à–µ–ª–µ–∫ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —Ç–æ–∫–µ–Ω–æ–≤ CES –∏ POL';
      
        const keyboard = Markup.inlineKeyboard([
          [Markup.button.callback('‚ûï –°–æ–∑–¥–∞—Ç—å –∫–æ—à–µ–ª–µ–∫', 'create_wallet')]
        ]);
      
        await ctx.reply(message, keyboard);
      }
      
    } catch (error) {
      console.error('Error showing personal cabinet:', error);
      try {
        await ctx.reply('‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –ª–∏—á–Ω–æ–≥–æ –∫–∞–±–∏–Ω–µ—Ç–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.');
      } catch (replyError) {
        console.error('Failed to send error message:', replyError);
      }
    }
  }

  // Handle user profile
  async handleUserProfile(ctx) {
    try {
      const chatId = ctx.chat.id.toString();
      const walletInfo = await walletService.getUserWallet(chatId);
      
      if (!walletInfo) {
        return await ctx.reply('‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω. –í—ã–ø–æ–ª–Ω–∏—Ç–µ /start');
      }
      
      let message = 'üë§ –õ–ò–ß–ù–´–ô –ö–ê–ë–ò–ù–ï–¢\n' +
                   '‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ\n';
      
      if (walletInfo.hasWallet) {
        // Get current price data for both tokens
        const [cesData, polData] = await Promise.all([
          priceService.getCESPrice(),
          priceService.getPOLPrice()
        ]);
        
        const cesTokenPrice = cesData ? cesData.price : 0;
        const cesTokenPriceRub = cesData ? cesData.priceRub : 0;
        const polTokenPrice = polData ? polData.price : 0.45;
        const polTokenPriceRub = polData ? polData.priceRub : 45.0;
        
        // Calculate total value of tokens on wallet
        const cesTotalUsd = (walletInfo.cesBalance * cesTokenPrice).toFixed(2);
        const cesTotalRub = (walletInfo.cesBalance * cesTokenPriceRub).toFixed(2);
        const polTotalUsd = (walletInfo.polBalance * polTokenPrice).toFixed(2);
        const polTotalRub = (walletInfo.polBalance * polTokenPriceRub).toFixed(2);
        
        message += `–ë–∞–ª–∞–Ω—Å CES: ${walletInfo.cesBalance.toFixed(4)} ‚Ä¢ $ ${cesTotalUsd} ‚Ä¢ ‚ÇΩ ${cesTotalRub}\n`;
        message += `–ë–∞–ª–∞–Ω—Å POL: ${walletInfo.polBalance.toFixed(4)} ‚Ä¢ $ ${polTotalUsd} ‚Ä¢ ‚ÇΩ ${polTotalRub}\n`;
        
        const keyboard = Markup.inlineKeyboard([
          [Markup.button.callback('üí≥ –ö–æ—à–µ–ª–µ–∫', 'wallet_details')],
          [Markup.button.callback('üí∏ –ü–µ—Ä–µ–≤–æ–¥', 'transfer_menu')],
          [Markup.button.callback('üîÑ –û–±–Ω–æ–≤–∏—Ç—å', 'refresh_balance')]
        ]);
        
        await ctx.reply(message, { parse_mode: 'Markdown', ...keyboard });
        
      } else {
        message += '‚ö†Ô∏è –ö–æ—à–µ–ª–µ–∫ –Ω–µ —Å–æ–∑–¥–∞–Ω\n\n';
        message += 'üí° –°–æ–∑–¥–∞–π—Ç–µ –∫–æ—à–µ–ª–µ–∫ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —Ç–æ–∫–µ–Ω–æ–≤ CES –∏ POL';
        
        // Remove the –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é button
        const keyboard = Markup.inlineKeyboard([
          [Markup.button.callback('‚ûï –°–æ–∑–¥–∞—Ç—å –∫–æ—à–µ–ª–µ–∫', 'create_wallet')]
        ]);
        
        await ctx.reply(message, keyboard);
      }
      
    } catch (error) {
      console.error('Error showing personal cabinet:', error);
      await ctx.reply('‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –ª–∏—á–Ω–æ–≥–æ –∫–∞–±–∏–Ω–µ—Ç–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.');
    }
  }

  // Handle wallet creation
  async handleCreateWallet(ctx) {
    try {
      // Immediate callback response
      await ctx.answerCbQuery('üî® –°–æ–∑–¥–∞–µ–º –∫–æ—à–µ–ª–µ–∫...');
      
      const chatId = ctx.chat.id.toString();
      const walletResult = await walletService.createUserWallet(chatId);
      
      const keyboard = Markup.inlineKeyboard([
        [Markup.button.callback('üîô –ù–∞–∑–∞–¥ –∫ –∫–∞–±–∏–Ω–µ—Ç—É', 'personal_cabinet')],
        [Markup.button.callback('üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é', 'back_to_menu')]
      ]);
      
      await ctx.reply(
        `–ö–æ—à–µ–ª–µ–∫ —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω!\n\n` +
        `–ê–¥—Ä–µ—Å: \`${walletResult.address}\`\n` +
        `–°–µ—Ç—å: Polygon\n\n` +
        `–í–∞–∂–Ω–æ: –°–æ—Ö—Ä–∞–Ω–∏—Ç–µ –ø—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á –≤ –±–µ–∑–æ–ø–∞—Å–Ω–æ–º –º–µ—Å—Ç–µ:\n` +
        `\`${walletResult.privateKey}\`\n\n` +
        `–ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ: –ù–∏–∫–æ–º—É –Ω–µ —Å–æ–æ–±—â–∞–π—Ç–µ –≤–∞—à –ø—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á!`,
        keyboard
      );
      
    } catch (error) {
      console.error('Wallet creation error:', error);
      await ctx.reply(`‚ùå ${error.message}`);
    }
  }

  // Handle wallet editing menu
  async handleWalletEdit(ctx) {
    try {
      // Immediate callback response
      await ctx.answerCbQuery('‚öôÔ∏è –ó–∞–≥—Ä—É–∂–∞–µ–º –º–µ–Ω—é...');
      
      const message = '‚öôÔ∏è **–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–æ—à–µ–ª—å–∫–∞**\n\n' +
                     '–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:';
      
      const keyboard = Markup.inlineKeyboard([
        [Markup.button.callback('üîë –ü–æ–∫–∞–∑–∞—Ç—å –ø—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á', 'show_private_key')],
        [Markup.button.callback('üì§ –≠–∫—Å–ø–æ—Ä—Ç –∫–æ—à–µ–ª—å–∫–∞', 'export_wallet')],
        [Markup.button.callback('üóë –£–¥–∞–ª–∏—Ç—å –∫–æ—à–µ–ª–µ–∫', 'delete_wallet')],
        [Markup.button.callback('üîô –ù–∞–∑–∞–¥ –∫ –∫–∞–±–∏–Ω–µ—Ç—É', 'personal_cabinet')]
      ]);
      
      await ctx.reply(message, { parse_mode: 'Markdown', ...keyboard });
      
    } catch (error) {
      console.error('Wallet edit menu error:', error);
      await ctx.reply('‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –º–µ–Ω—é. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.');
    }
  }

  // Handle wallet details view
  async handleWalletDetails(ctx) {
    try {
      // Immediate callback response
      await ctx.answerCbQuery('üí≥ –ó–∞–≥—Ä—É–∂–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∫–æ—à–µ–ª—å–∫–∞...');
      
      const chatId = ctx.chat.id.toString();
      const walletInfo = await walletService.getUserWallet(chatId);

      if (!walletInfo || !walletInfo.hasWallet) {
        return await ctx.reply('‚ùå –ö–æ—à–µ–ª–µ–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω.');
      }

      // Get private key for display
      const privateKey = await walletService.getUserPrivateKey(chatId);

      // Format as requested
      const message = 'üí≥ –ö–û–®–ï–õ–ï–ö\n' +
                     '‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ\n' +
                     `–ê–¥—Ä–µ—Å: \n${walletInfo.address}\n\n` +
                     `–ü—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á: ${privateKey}\n\n` +
                     `‚ö†Ô∏è –í–∞–∂–Ω–æ:\n` +
                     `–°–æ—Ö—Ä–∞–Ω–∏—Ç–µ –¥–∞–Ω–Ω—ã–µ –≤ –±–µ–∑–æ–ø–∞—Å–Ω–æ–º –º–µ—Å—Ç–µ\n` +
                     `–ù–∏–∫–æ–º—É –Ω–µ –ø–µ—Ä–µ–¥–∞–≤–∞–π—Ç–µ –ø—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á\n` +
                     `–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –¥–ª—è –∏–º–ø–æ—Ä—Ç–∞ –≤ –¥—Ä—É–≥–∏–µ –∫–æ—à–µ–ª—å–∫–∏`;

      // Simplified keyboard with only back button
      const keyboard = Markup.inlineKeyboard([
        [Markup.button.callback('üîô –ù–∞–∑–∞–¥', 'personal_cabinet')]
      ]);

      await ctx.reply(message, keyboard);

    } catch (error) {
      console.error('Wallet details error:', error);
      await ctx.reply('‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö –∫–æ—à–µ–ª—å–∫–∞.');
    }
  }

  // Show private key
  async handleShowPrivateKey(ctx) {
    try {
      const chatId = ctx.chat.id.toString();
      const privateKey = await walletService.getUserPrivateKey(chatId);
      
      const message = `üîë **–ü—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á**\n\n` +
                     `‚ö†Ô∏è **–û—Å—Ç–æ—Ä–æ–∂–Ω–æ!** –ù–∏–∫–æ–º—É –Ω–µ –ø–æ–∫–∞–∑—ã–≤–∞–π—Ç–µ —ç—Ç–æ—Ç –∫–ª—é—á!\n\n` +
                     `üîê \`${privateKey}\``;
      
      const keyboard = Markup.inlineKeyboard([
        [Markup.button.callback('üîô –ù–∞–∑–∞–¥ –∫ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—é', 'edit_wallet')]
      ]);
      
      await ctx.reply(message, { parse_mode: 'Markdown', ...keyboard });
      
    } catch (error) {
      console.error('Show private key error:', error);
      await ctx.reply(`‚ùå ${error.message}`);
    }
  }

  // Handle wallet export
  async handleExportWallet(ctx) {
    try {
      const chatId = ctx.chat.id.toString();
      const walletInfo = await walletService.getUserWallet(chatId);
      const privateKey = await walletService.getUserPrivateKey(chatId);
      
      if (!walletInfo || !walletInfo.hasWallet) {
        return await ctx.reply('‚ùå –ö–æ—à–µ–ª–µ–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω.');
      }
      
      const message = `üì§ **–≠–∫—Å–ø–æ—Ä—Ç –∫–æ—à–µ–ª—å–∫–∞**\n\n` +
                     `üí≥ –ê–¥—Ä–µ—Å: \`${walletInfo.address}\`\n` +
                     `üîë –ü—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á: \`${privateKey}\`\n\n` +
                     `‚ö†Ô∏è **–í–∞–∂–Ω–æ:**\n` +
                     `‚Ä¢ –°–æ—Ö—Ä–∞–Ω–∏—Ç–µ —ç—Ç—É –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –≤ –±–µ–∑–æ–ø–∞—Å–Ω–æ–º –º–µ—Å—Ç–µ\n` +
                     `‚Ä¢ –ù–∏–∫–æ–º—É –Ω–µ –ø–µ—Ä–µ–¥–∞–≤–∞–π—Ç–µ –ø—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á\n` +
                     `‚Ä¢ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –¥–ª—è –∏–º–ø–æ—Ä—Ç–∞ –≤ –¥—Ä—É–≥–∏–µ –∫–æ—à–µ–ª—å–∫–∏`;
      
      const keyboard = Markup.inlineKeyboard([
        [Markup.button.callback('üîô –ù–∞–∑–∞–¥ –∫ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—é', 'edit_wallet')]
      ]);
      
      await ctx.reply(message, { parse_mode: 'Markdown', ...keyboard });
      
    } catch (error) {
      console.error('Export wallet error:', error);
      await ctx.reply(`‚ùå ${error.message}`);
    }
  }

  // Handle wallet deletion
  async handleDeleteWallet(ctx) {
    try {
      const message = `‚ö†Ô∏è **–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ —É–¥–∞–ª–µ–Ω–∏—è**\n\n` +
                     `üóë –í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —É–¥–∞–ª–∏—Ç—å –∫–æ—à–µ–ª–µ–∫?\n\n` +
                     `‚ùó **–≠—Ç–æ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–µ–ª—å–∑—è –æ—Ç–º–µ–Ω–∏—Ç—å!**\n` +
                     `‚Ä¢ –í—Å–µ –¥–∞–Ω–Ω—ã–µ –∫–æ—à–µ–ª—å–∫–∞ –±—É–¥—É—Ç —É–¥–∞–ª–µ–Ω—ã\n` +
                     `‚Ä¢ –î–æ—Å—Ç—É–ø –∫ —Å—Ä–µ–¥—Å—Ç–≤–∞–º –±—É–¥–µ—Ç —É—Ç—Ä–∞—á–µ–Ω`;
      
      const keyboard = Markup.inlineKeyboard([
        [Markup.button.callback('‚úÖ –î–∞, —É–¥–∞–ª–∏—Ç—å', 'confirm_delete_wallet')],
        [Markup.button.callback('‚ùå –û—Ç–º–µ–Ω–∞', 'edit_wallet')]
      ]);
      
      await ctx.reply(message, { parse_mode: 'Markdown', ...keyboard });
      
    } catch (error) {
      console.error('Delete wallet confirmation error:', error);
      await ctx.reply('‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è —É–¥–∞–ª–µ–Ω–∏—è.');
    }
  }

  // Confirm wallet deletion
  async handleConfirmDeleteWallet(ctx) {
    try {
      const chatId = ctx.chat.id.toString();
      await walletService.deleteUserWallet(chatId);
      
      const message = `‚úÖ **–ö–æ—à–µ–ª–µ–∫ —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω**\n\n` +
                     `üóë –í—Å–µ –¥–∞–Ω–Ω—ã–µ –∫–æ—à–µ–ª—å–∫–∞ —É–¥–∞–ª–µ–Ω—ã\n` +
                     `üîÑ –í—ã –º–æ–∂–µ—Ç–µ —Å–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π –∫–æ—à–µ–ª–µ–∫`;
      
      const keyboard = Markup.inlineKeyboard([
        [Markup.button.callback('‚ûï –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π', 'create_wallet')],
        [Markup.button.callback('üîô –ö –ª–∏—á–Ω–æ–º—É –∫–∞–±–∏–Ω–µ—Ç—É', 'personal_cabinet')]
      ]);
      
      await ctx.reply(message, { parse_mode: 'Markdown', ...keyboard });
      
    } catch (error) {
      console.error('Confirm delete wallet error:', error);
      await ctx.reply(`‚ùå –û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è: ${error.message}`);
    }
  }

  // Refresh balance
  async handleRefreshBalance(ctx) {
    try {
      await this.handleUserProfile(ctx);
    } catch (error) {
      // Handle "message not modified" error gracefully
      if (error.response && error.response.error_code === 400 && 
          error.response.description.includes('message is not modified')) {
        console.log('Ignoring "message not modified" error during refresh');
        // Message is already up to date, no need to show error
      } else {
        console.error('Refresh balance error:', error);
        await ctx.reply('‚ùå –û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –±–∞–ª–∞–Ω—Å–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.');
      }
    }
  }
}

module.exports = WalletHandler;