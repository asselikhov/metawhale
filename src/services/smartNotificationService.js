/**
 * Smart Notification Service
 * AI-powered notification system for P2P trading platform
 */

const { User, P2POrder, P2PTrade } = require('../database/models');
const config = require('../config/configuration');
// Remove direct bot import to avoid circular dependencies
// const bot = require('../bot/telegramBot').getInstance();

class SmartNotificationService {
  constructor() {
    this.notificationQueue = [];
    this.isProcessing = false;
    this.userPreferences = new Map();
  }

  // Send smart order match notification
  async sendSmartOrderMatchNotification(userId, matchedOrder, ownOrder) {
    try {
      const user = await User.findById(userId);
      if (!user) return;

      // Check user preferences
      const prefs = await this.getUserNotificationPreferences(userId);
      if (!prefs.orderMatches) return;

      const chatId = user.chatId;
      
      // Personalize notification based on user behavior
      const personalizedMessage = this.generatePersonalizedMatchMessage(
        user, matchedOrder, ownOrder
      );
      
      // Add to notification queue
      this.notificationQueue.push({
        chatId,
        message: personalizedMessage,
        type: 'smart_order_match',
        timestamp: new Date(),
        priority: this.calculateNotificationPriority(user, matchedOrder)
      });
      
      this.processNotificationQueue();
      
    } catch (error) {
      console.error('Error sending smart order match notification:', error);
    }
  }

  // Generate personalized match message
  generatePersonalizedMatchMessage(user, matchedOrder, ownOrder) {
    try {
      const typeText = ownOrder.type === 'buy' ? '–ø–æ–∫—É–ø–∫–∏' : '–ø—Ä–æ–¥–∞–∂–∏';
      const oppositeTypeText = ownOrder.type === 'buy' ? '–ø—Ä–æ–¥–∞–∂–∏' : '–ø–æ–∫—É–ø–∫–∏';
      
      // Get user's preferred payment methods
      const preferredMethods = user.preferredPaymentMethods || ['bank_transfer'];
      const hasPreferredMethod = preferredMethods.includes(matchedOrder.paymentMethods[0]);
      
      // Get trust score information
      const trustScore = matchedOrder.userId.trustScore !== undefined ? matchedOrder.userId.trustScore : 100;
      const trustLevel = trustScore > 800 ? '–í—ã—Å–æ–∫–∏–π' : trustScore > 500 ? '–°—Ä–µ–¥–Ω–∏–π' : '–ù–∏–∑–∫–∏–π';
      
      let message = `üîî –ù–∞–π–¥–µ–Ω –ø–æ–¥—Ö–æ–¥—è—â–∏–π –æ—Ä–¥–µ—Ä –¥–ª—è ${typeText}!\n\n` +
                   `üí∞ –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ: ${matchedOrder.remainingAmount.toFixed(2)} CES\n` +
                   `üíµ –¶–µ–Ω–∞: ‚ÇΩ${matchedOrder.pricePerToken.toFixed(2)} –∑–∞ —Ç–æ–∫–µ–Ω\n` +
                   `üë§ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: ${matchedOrder.userId.username || '–ê–Ω–æ–Ω–∏–º'}\n` +
                   `‚≠ê –†–µ–π—Ç–∏–Ω–≥: ${trustScore}/1000 (${trustLevel})\n`;
      
      if (hasPreferredMethod) {
        message += `‚úÖ –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –≤–∞—à —Å–ø–æ—Å–æ–± –æ–ø–ª–∞—Ç—ã\n`;
      }
      
      message += `\n–•–æ—Ç–∏—Ç–µ –∏—Å–ø–æ–ª–Ω–∏—Ç—å —Å–¥–µ–ª–∫—É?`;
      
      return message;
    } catch (error) {
      console.error('Error generating personalized message:', error);
      // Fallback message
      return `üîî –ù–∞–π–¥–µ–Ω –ø–æ–¥—Ö–æ–¥—è—â–∏–π –æ—Ä–¥–µ—Ä!\n\n–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –¥–µ—Ç–∞–ª–∏ –≤ —Ä–∞–∑–¥–µ–ª–µ –∞–∫—Ç–∏–≤–Ω—ã—Ö –æ—Ä–¥–µ—Ä–æ–≤.`;
    }
  }

  // Calculate notification priority
  calculateNotificationPriority(user, matchedOrder) {
    try {
      let priority = 0;
      
      // Higher priority for users with higher trust scores
      const userTrustScore = user.trustScore !== undefined ? user.trustScore : 100;
      priority += userTrustScore / 100;
      
      // Higher priority for orders with larger amounts
      priority += matchedOrder.remainingAmount;
      
      // Higher priority for orders with better prices
      const marketPrice = matchedOrder.pricePerToken; // Simplified
      priority += marketPrice / 10;
      
      // Higher priority for verified users
      if (user.verificationLevel !== 'unverified') {
        priority += 10;
      }
      
      return Math.round(priority);
    } catch (error) {
      console.error('Error calculating notification priority:', error);
      return 0;
    }
  }

  // Send trade status update with smart insights
  async sendSmartTradeStatusNotification(userId, trade, status) {
    try {
      const user = await User.findById(userId);
      if (!user) return;

      // Check user preferences
      const prefs = await this.getUserNotificationPreferences(userId);
      if (!prefs.tradeUpdates) return;

      const chatId = user.chatId;
      let message = '';
      
      console.log(`üîç [SMART-NOTIFICATION] Generating message for status: ${status}, user: ${user.chatId}`);
      
      switch (status) {
        case 'payment_pending':
          message = this.generatePaymentPendingMessage(user, trade);
          break;
          
        case 'payment_completed':
          message = this.generatePaymentCompletedMessage(user, trade);
          break;
          
        case 'payment_confirmed':
          message = this.generatePaymentConfirmedMessage(user, trade);
          break;
          
        case 'completed':
          message = this.generateTradeCompletedMessage(user, trade);
          break;
          
        case 'cancelled':
          message = this.generateTradeCancelledMessage(user, trade);
          break;
          
        case 'timeout':
          message = this.generateTradeTimeoutMessage(user, trade);
          break;
          
        default:
          console.warn(`‚ö†Ô∏è [SMART-NOTIFICATION] Unknown status: ${status}`);
          message = `‚ÑπÔ∏è –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ —Å–¥–µ–ª–∫–µ #${trade._id.toString().substr(0, 8)}`;
      }
      
      console.log(`üìù [SMART-NOTIFICATION] Generated message: "${message}"`);
      
      if (!message || message.trim() === '') {
        console.error(`‚ùå [SMART-NOTIFICATION] Empty message generated for status: ${status}`);
        return; // Don't send empty messages
      }

      // Add to notification queue
      this.notificationQueue.push({
        chatId,
        message,
        type: 'smart_trade_status',
        timestamp: new Date()
      });
      
      this.processNotificationQueue();
      
    } catch (error) {
      console.error('Error sending smart trade status notification:', error);
    }
  }

  // Generate payment pending message
  generatePaymentPendingMessage(user, trade) {
    try {
      const timeLimit = trade.timeTracking?.expiresAt 
        ? Math.ceil((trade.timeTracking.expiresAt - new Date()) / (60 * 1000)) 
        : config.escrow.timeoutMinutes;
      
      return `‚è≥ –û–ø–ª–∞—Ç–∞ –æ–∂–∏–¥–∞–µ—Ç—Å—è\n\n` +
            `–°–¥–µ–ª–∫–∞ #${trade._id.toString().substr(0, 8)}\n` +
            `üí∞ –°—É–º–º–∞: ‚ÇΩ${trade.totalValue.toFixed(2)}\n` +
            `üïê –í—Ä–µ–º—è –Ω–∞ –æ–ø–ª–∞—Ç—É: ${config.escrow.displayFormat.minutes(timeLimit)}\n\n` +
            `–ù–µ –∑–∞–±—É–¥—å—Ç–µ –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –æ–ø–ª–∞—Ç—É –ø–æ—Å–ª–µ –ø–µ—Ä–µ–≤–æ–¥–∞ —Å—Ä–µ–¥—Å—Ç–≤!`;
    } catch (error) {
      return `‚è≥ –û–ø–ª–∞—Ç–∞ –æ–∂–∏–¥–∞–µ—Ç—Å—è\n\n` +
            `–°–¥–µ–ª–∫–∞ #${trade._id.toString().substr(0, 8)}\n` +
            `üí∞ –°—É–º–º–∞: ‚ÇΩ${trade.totalValue.toFixed(2)}\n` +
            `üïê –í—Ä–µ–º—è –Ω–∞ –æ–ø–ª–∞—Ç—É: ${config.escrow.displayFormat.minutes(config.escrow.timeoutMinutes)}`;
    }
  }

  // Generate payment confirmed message
  generatePaymentConfirmedMessage(user, trade) {
    return `‚úÖ –û–ø–ª–∞—Ç–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞\n\n` +
          `–°–¥–µ–ª–∫–∞ #${trade._id.toString().substr(0, 8)}\n` +
          `–¢–æ–∫–µ–Ω—ã –±—É–¥—É—Ç –ø–µ—Ä–µ–≤–µ–¥–µ–Ω—ã –≤ –±–ª–∏–∂–∞–π—à–µ–µ –≤—Ä–µ–º—è\n\n` +
          `–°–ø–∞—Å–∏–±–æ –∑–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –Ω–∞—à–µ–π P2P –±–∏—Ä–∂–∏!`;
  }

  // Generate payment completed message
  generatePaymentCompletedMessage(user, trade) {
    // When seller marks payment as completed, we notify the buyer (maker)
    // user parameter is the buyer who receives notification
    // trade.sellerId is who marked payment as completed
    const isBuyer = trade.buyerId._id.toString() === user._id.toString();
    
    if (isBuyer) {
      // Message for buyer (maker) - seller marked payment as completed
      return `üí∞ –ü–ª–∞—Ç—ë–∂ –æ—Ç–º–µ—á–µ–Ω –∫–∞–∫ –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã–π!\n\n` +
            `–°–¥–µ–ª–∫–∞ #${trade._id.toString().substr(0, 8)}\n` +
            `üí∞ –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ: ${trade.amount.toFixed(2)} CES\n` +
            `üíµ –°—É–º–º–∞: ‚ÇΩ${trade.totalValue.toFixed(2)}\n\n` +
            `–ü—Ä–æ–¥–∞–≤–µ—Ü –æ—Ç–º–µ—Ç–∏–ª, —á—Ç–æ –ø–æ–ª—É—á–∏–ª –æ–ø–ª–∞—Ç—É.\n` +
            `CES –±—É–¥—É—Ç –æ—Å–≤–æ–±–æ–∂–¥–µ–Ω—ã —Å —ç—Å–∫—Ä–æ—É –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏.`;
    } else {
      // Message for seller - fallback (shouldn't normally happen)
      return `‚úÖ –ü–ª–∞—Ç—ë–∂ –æ—Ç–º–µ—á–µ–Ω –∫–∞–∫ –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã–π\n\n` +
            `–°–¥–µ–ª–∫–∞ #${trade._id.toString().substr(0, 8)}\n` +
            `–û–∂–∏–¥–∞–µ–º –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –æ—Ç –ø–æ–∫—É–ø–∞—Ç–µ–ª—è.`;
    }
  }

  // Generate trade completed message
  generateTradeCompletedMessage(user, trade) {
    const isBuyer = trade.buyerId._id.toString() === user._id.toString();
    const roleText = isBuyer ? '–ø–æ–∫—É–ø–∞—Ç–µ–ª—è' : '–ø—Ä–æ–¥–∞–≤—Ü–∞';
    const amountText = isBuyer 
      ? `–ü–æ–ª—É—á–µ–Ω–æ: ${trade.amount.toFixed(2)} CES` 
      : `–ü—Ä–æ–¥–∞–Ω–æ: ${trade.amount.toFixed(2)} CES`;
    
    return `üéâ –°–¥–µ–ª–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!\n\n` +
          `–°–¥–µ–ª–∫–∞ #${trade._id.toString().substr(0, 8)}\n` +
          `${amountText}\n` +
          `üíµ –°—É–º–º–∞: ‚ÇΩ${trade.totalValue.toFixed(2)}\n\n` +
          `–°–ø–∞—Å–∏–±–æ –∑–∞ —É—á–∞—Å—Ç–∏–µ –≤ —Å–¥–µ–ª–∫–µ –∫–∞–∫ ${roleText}!`;
  }

  // Generate trade cancelled message
  generateTradeCancelledMessage(user, trade) {
    return `‚ùå –°–¥–µ–ª–∫–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞\n\n` +
          `–°–¥–µ–ª–∫–∞ #${trade._id.toString().substr(0, 8)}\n` +
          `–ü—Ä–∏—á–∏–Ω–∞: ${trade.disputeReason || '–û—Ç–º–µ–Ω–µ–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º'}\n\n` +
          `–°—Ä–µ–¥—Å—Ç–≤–∞ –≤–æ–∑–≤—Ä–∞—â–µ–Ω—ã –≤ –∫–æ—à–µ–ª–µ–∫`;
  }

  // Generate trade timeout message
  generateTradeTimeoutMessage(user, trade) {
    return `‚è∞ –í—Ä–µ–º—è —Å–¥–µ–ª–∫–∏ –∏—Å—Ç–µ–∫–ª–æ\n\n` +
          `–°–¥–µ–ª–∫–∞ #${trade._id.toString().substr(0, 8)}\n` +
          `–°—Ä–µ–¥—Å—Ç–≤–∞ –≤–æ–∑–≤—Ä–∞—â–µ–Ω—ã –≤ –∫–æ—à–µ–ª–µ–∫\n\n` +
          `–ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é —Å–¥–µ–ª–∫—É —Å –¥—Ä—É–≥–∏–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º`;
  }

  // Send personalized market insights
  async sendPersonalizedMarketInsights(userId) {
    try {
      const user = await User.findById(userId);
      if (!user) return;

      // Check user preferences
      const prefs = await this.getUserNotificationPreferences(userId);
      if (!prefs.marketInsights) return;

      // Get user's trading history
      const userTrades = await P2PTrade.find({
        $or: [{ buyerId: userId }, { sellerId: userId }],
        createdAt: { $gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) } // Last 7 days
      });

      if (userTrades.length === 0) return; // No recent trades

      // Get market analytics service
      const analyticsService = require('./analyticsService');
      const insights = await analyticsService.getAIInsights();
      
      // Personalize insights based on user behavior
      const personalizedInsights = this.personalizeMarketInsights(user, userTrades, insights);
      
      const chatId = user.chatId;
      const message = `üìà –ü–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–µ —Ä—ã–Ω–æ—á–Ω—ã–µ –∏–Ω—Å–∞–π—Ç—ã\n\n` +
                     `${personalizedInsights.trend}\n` +
                     `–£–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å: ${(personalizedInsights.confidence * 100).toFixed(0)}%\n` +
                     `–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è: ${personalizedInsights.recommendation}`;

      // Add to notification queue
      this.notificationQueue.push({
        chatId,
        message,
        type: 'personalized_insights',
        timestamp: new Date()
      });
      
      this.processNotificationQueue();
      
    } catch (error) {
      console.error('Error sending personalized market insights:', error);
    }
  }

  // Personalize market insights
  personalizeMarketInsights(user, userTrades, marketInsights) {
    try {
      // Analyze user's recent trading behavior
      const avgTradeSize = userTrades.reduce((sum, trade) => sum + trade.amount, 0) / userTrades.length;
      const preferredTradeSize = avgTradeSize > 100 ? 'large' : avgTradeSize > 10 ? 'medium' : 'small';
      
      // Adjust recommendation based on user behavior
      let recommendation = marketInsights.recommendation;
      
      if (preferredTradeSize === 'large' && marketInsights.trend.includes('–ë—ã—á–∏–π')) {
        recommendation += '. –†–∞—Å—Å–º–æ—Ç—Ä–∏—Ç–µ –∫—Ä—É–ø–Ω—ã–µ —Å–¥–µ–ª–∫–∏ –¥–ª—è –º–∞–∫—Å–∏–º–∏–∑–∞—Ü–∏–∏ –ø—Ä–∏–±—ã–ª–∏.';
      } else if (preferredTradeSize === 'small' && marketInsights.trend.includes('–ú–µ–¥–≤–µ–∂–∏–π')) {
        recommendation += '. –†–∞—Å—Å–º–æ—Ç—Ä–∏—Ç–µ –Ω–µ–±–æ–ª—å—à–∏–µ —Å–¥–µ–ª–∫–∏ –¥–ª—è –º–∏–Ω–∏–º–∏–∑–∞—Ü–∏–∏ —Ä–∏—Å–∫–æ–≤.';
      }
      
      return {
        trend: marketInsights.trend,
        confidence: marketInsights.confidence,
        recommendation: recommendation
      };
    } catch (error) {
      console.error('Error personalizing market insights:', error);
      return marketInsights;
    }
  }

  // Send daily summary notification
  async sendDailySummary(userId) {
    try {
      const user = await User.findById(userId);
      if (!user) return;

      // Check user preferences
      const prefs = await this.getUserNotificationPreferences(userId);
      if (!prefs.dailySummary) return;

      // Get user's daily trading stats
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      
      const dailyTrades = await P2PTrade.find({
        $or: [{ buyerId: userId }, { sellerId: userId }],
        createdAt: { $gte: today }
      });

      if (dailyTrades.length === 0) return; // No trades today

      const completedTrades = dailyTrades.filter(t => t.status === 'completed');
      const totalVolume = completedTrades.reduce((sum, trade) => sum + trade.totalValue, 0);
      
      const chatId = user.chatId;
      const message = `üìÖ –ï–∂–µ–¥–Ω–µ–≤–Ω—ã–π –æ—Ç—á–µ—Ç\n\n` +
                     `–°–¥–µ–ª–æ–∫ —Å–µ–≥–æ–¥–Ω—è: ${dailyTrades.length}\n` +
                     `–ó–∞–≤–µ—Ä—à–µ–Ω–æ: ${completedTrades.length}\n` +
                     `–û–±—ä–µ–º: ‚ÇΩ${totalVolume.toLocaleString('ru-RU')}\n\n` +
                     `–°–ø–∞—Å–∏–±–æ –∑–∞ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –Ω–∞ –Ω–∞—à–µ–π P2P –±–∏—Ä–∂–µ!`;

      // Add to notification queue
      this.notificationQueue.push({
        chatId,
        message,
        type: 'daily_summary',
        timestamp: new Date()
      });
      
      this.processNotificationQueue();
      
    } catch (error) {
      console.error('Error sending daily summary:', error);
    }
  }

  // Process notification queue with priority
  async processNotificationQueue() {
    if (this.isProcessing || this.notificationQueue.length === 0) {
      return;
    }
    
    this.isProcessing = true;
    
    try {
      // Sort notifications by priority (higher first)
      this.notificationQueue.sort((a, b) => (b.priority || 0) - (a.priority || 0));
      
      while (this.notificationQueue.length > 0) {
        const notification = this.notificationQueue.shift();
        
        // Send notification with rate limiting
        await this.sendNotification(notification);
        
        // Small delay to prevent overwhelming the bot
        await new Promise(resolve => setTimeout(resolve, 100));
      }
    } catch (error) {
      console.error('Error processing notification queue:', error);
    } finally {
      this.isProcessing = false;
    }
  }

  // Send individual notification
  async sendNotification(notification) {
    try {
      // In a real implementation, you would send the actual Telegram message
      console.log(`[SMART NOTIFICATION] To ${notification.chatId}: ${notification.message}`);
      
      // To avoid circular dependencies, we'll use a callback approach
      // The actual sending will be handled by the message handler
      if (this.notificationCallback) {
        await this.notificationCallback(notification.chatId, notification.message);
      }
      
    } catch (error) {
      console.error('Error sending notification:', error);
      
      // Re-queue failed notifications
      if (notification.retryCount < 3) {
        notification.retryCount = (notification.retryCount || 0) + 1;
        this.notificationQueue.push(notification);
      }
    }
  }

  // Set notification callback (to avoid circular dependencies)
  setNotificationCallback(callback) {
    this.notificationCallback = callback;
  }

  // Get user notification preferences
  async getUserNotificationPreferences(userId) {
    try {
      // Check cache first
      if (this.userPreferences.has(userId.toString())) {
        return this.userPreferences.get(userId.toString());
      }
      
      const user = await User.findById(userId);
      if (!user) return null;
      
      const prefs = {
        orderMatches: user.notificationPrefs?.orderMatches !== false,
        tradeUpdates: user.notificationPrefs?.tradeUpdates !== false,
        marketInsights: user.notificationPrefs?.marketInsights !== false,
        dailySummary: user.notificationPrefs?.dailySummary !== false
      };
      
      // Cache preferences
      this.userPreferences.set(userId.toString(), prefs);
      
      return prefs;
    } catch (error) {
      console.error('Error getting user notification preferences:', error);
      return {
        orderMatches: true,
        tradeUpdates: true,
        marketInsights: true,
        dailySummary: true
      };
    }
  }

  // Update user notification preferences
  async updateUserNotificationPreferences(userId, preferences) {
    try {
      await User.findByIdAndUpdate(userId, {
        notificationPrefs: preferences
      });
      
      // Update cache
      this.userPreferences.set(userId.toString(), preferences);
      
      console.log(`Updated notification preferences for user ${userId}`);
    } catch (error) {
      console.error('Error updating user notification preferences:', error);
    }
  }

  // Clear user preferences cache
  clearUserPreferencesCache(userId) {
    if (userId) {
      this.userPreferences.delete(userId.toString());
    } else {
      this.userPreferences.clear();
    }
  }
}

module.exports = new SmartNotificationService();